set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

Plugin 'mileszs/ack.vim'
Plugin 'ekalinin/Dockerfile.vim'
Plugin 'scrooloose/nerdcommenter'
Plugin 'scrooloose/nerdtree'
Plugin 'ervandew/supertab'
Plugin 'godlygeek/tabular'
Plugin 'kchmck/vim-coffee-script'
Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-rails'
Plugin 'jpo/vim-railscasts-theme'
Plugin 'ngmy/vim-rubocop'
Plugin 'slim-template/vim-slim'
Plugin 'Matt-Deacalion/vim-systemd-syntax'


" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required

let g:vimrubocop_config = '~/.vim/config/rubocop.yml'


" Custom config
syntax on

set ic
set nu
set ea
set hls is
set nowrap                                            " Line wrapping off
set timeoutlen=250                                    " Time to wait after ESC (default causes an annoying delay)

" Strip trailing white spaces
autocmd BufWritePre *.md,*.js,*.rb,*.html,*.haml,*.erb,*.css,*.sass,*.coffee,*.yml call StripTrailingWhiteSpaces()

" Color
set t_Co=256
colors railscasts
" Ruby {
   " ruby standard 2 spaces, always
       au BufRead,BufNewFile *.rb,*.rhtml,*.erb,*.haml,*.js set shiftwidth=2
       au BufRead,BufNewFile *.rb,*.rhtml,*.erb,*.haml,*.js set softtabstop=2
       au BufRead,BufNewFile *.haml setf haml
       au BufRead,BufNewFile *.scss setf sass
" }
"

" Formatting (some of these are for coding in C and C++)
set ts=2                                              " Tabs are 2 spaces
set bs=2                                              " Backspace over everything in insert mode
set softtabstop=2
set shiftwidth=2                                      " Tabs under smart indent
set autoindent
set smarttab
set expandtab
set smartindent
set virtualedit=all
set encoding=utf-8
set showmatch                                          " Show matching brackets.

set guifont=Menlo\ Regular:h14                         " Default font-size to 14px

" Visual
set mat=5                                              " Bracket blinking.
" set list                                             " Show $ at end of line and trailing space as ~
"set lcs=tab:\ \ ,eol:$,trail:~,extends:>,precedes:<
"set laststatus=2                                       " Always show status line.

" gvim specific
" set mousehide                                          " Hide mouse after chars typed
set mouse=a                                            " Mouse in all modes

" Backups & Files
set backup                                             " Enable creation of backup file.
set backupdir=~/.vim/backup                            " Where backups will go.
set directory=~/.vim/tmp                               " Where temporary files will go.

" No sound on errors
set visualbell
set t_vb=
set tm=500

highlight LineNr term=bold cterm=NONE ctermfg=DarkGrey ctermbg=NONE gui=NONE guifg=DarkGrey guibg=NONE

if has("gui_running")
  set guioptions-=T
  set transparency=0
endif

" Make the current window big, but leave others context
" We have to have a winheight bigger than we want to set winminheight. But if
" we set winheight to be huge before winminheight, the winminheight set will
" fail.
set winheight=10
set winminheight=10
set winheight=999

" Strip trailing white spaces before file is saved
function! StripTrailingWhiteSpaces()
  " Store the current position
  let _s=@/
  let l = line(".")
  let c = col(".")
  " Strip white spaces
  %s/\s\+$//e
  " Restore previous search history and cursor position
  let @/=_s
  call cursor(l, c)
endfunction

" 80 character limit
if exists('+colorcolumn')
  hi ColorColumn guibg=#2d2d2d ctermbg=246
  set colorcolumn=80
else
  au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)
endif

function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction

" mapping to trigger the :Tabular command when you type the character that you want to align
inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a

map! <silent> <F2> <C-O>:w<CR>
map! <silent> <F3> <esc>:q<CR>
map! <silent> <F4> <esc>:NERDTreeToggle<CR>i

nmap <silent> <F2> :w<CR>
nmap <silent> <F3> :q<CR>
nmap <silent> <F4> :NERDTreeToggle<CR>

vmap <silent> <F5> :call NERDComment(1, "toggle")<CR>
nmap <silent> <F5> v :call NERDComment(1, "toggle")<CR>
imap <silent> <F5> <esc>v :call NERDComment(1, "toggle")<CR>

nmap <silent> <Space> zo<CR>
nmap <silent> <BS> za<CR>

vmap <silent> <F6> :tabnew<CR>
nmap <silent> <F6> :vsp<CR>
imap <silent> <F6> <ESC>:sp<CR>i

nnoremap <c-j> :m+<CR>==
nnoremap <c-k> :m-2<CR>==
inoremap <c-j> <Esc>:m+<CR>==gi
inoremap <c-k> <Esc>:m-2<CR>==gi
vnoremap <c-j> :m'>+<CR>gv=gv
vnoremap <c-k> :m-2<CR>gv=gv

" recording macro
nmap <C-A> @r

map <silent> <c-f> :FufFile **/<CR>
map <silent> <c-b> :FufBuffer **/<CR>

imap <silent> <c-f> <esc>:FufFile **/<CR>
imap <silent> <c-b> <esc>:FufBuffer **/<CR>

set pastetoggle=<F7>  " Toggle auto-indenting for code paste

" use the arrows to something usefull
map! <silent> <C-right> <esc>gt<CR>i
map! <silent> <C-left> <esc>gT<CR>i
nmap <silent> <C-right> gt
nmap <silent> <C-left> gT

" Clone Current Line And Puts It Down
vnoremap <silent> <c-d> Yp
inoremap <silent> <c-d> <Esc> Yp
nnoremap <silent> <c-d> Yp

vmap <C-c> y:call system("pbcopy", getreg("\""))<CR>
nmap <C-v> :call setreg("\"",system("pbpaste"))<CR>p


